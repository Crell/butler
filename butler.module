<?php

/**
 * Exception thrown when attempting to modify a locked context object.
 */
class ButlerLockedException extends Exception {}

/**
 * Exception thrown when attempting to use an unlocked context object.
 */
class ButlerNotLockedException extends Exception {}

interface DrupalRequestInterface {

}

class DrupalRequestHttp implements DrupalRequestInterface {

  protected $getQuery;

  protected $postQuery;

  protected $filesQuery;

  protected $cookieQuery;

  protected $requestQuery;

  protected $requestHeaders;

  public function __construct() {
    $this->getQuery = $_GET;
    $this->postQuery = $_POST;
    $this->filesQuery = $_FILES;
    $this->cookieQuery = $_COOKIE;
    $this->requestQuery = $_REQUEST;

    array_walk($this->getQuery, '_fix_gpc_magic');
    array_walk($this->postQuery, '_fix_gpc_magic');
    array_walk($this->filesQuery, '_fix_gpc_magic');
    array_walk($this->cookieQuery, '_fix_gpc_magic');
    array_walk($this->requestQuery, '_fix_gpc_magic');
  }

  public function __get($var) {
    if ($var == 'get') {
      return $this->getQuery;
    }
  }

  public function __set($var, $val) {
    if ($var == 'get' || $var == 'post') {
      // @todo Real error handling.
      return NULL;
    }

  }

  /**
   * Retrieves a value from the GET query.
   *
   * See the PHP ext/filter documentation for details.
   *
   * @link http://www.php.net/manual/en/book.filter.php
   *
   * @param string $param
   * @param int $filter
   * @param array $options
   *
   * @return mixed
   */
  public function get($param, $filter = FILTER_UNSAFE_RAW, $options = array()) {
    if (!empty($this->getQuery[$param])) {
      return filter_var($this->getQuery[$param], $filter, $options);
    }
    return FALSE;
  }

  /**
   * Retrieves a value from the POST query.
   *
   * See the PHP ext/filter documentation for details.
   *
   * @link http://www.php.net/manual/en/book.filter.php
   *
   * @param string $param
   * @param int $filter
   * @param array $options
   *
   * @return mixed
   */
  public function post($param, $filter = FILTER_UNSAFE_RAW, $options = array()) {
    if (!empty($this->postQuery[$param])) {
      return filter_var($this->postQuery[$param], $filter, $options);
    }
    return FALSE;
  }


  public function header($header) {
    // @todo This is, of course, Apache-specific.  We need to find the IIS
    // equilvalent, too.  Maybe that's even an alternate class implementation?
    if (!$this->headers) {
      $this->requestHeaders = apache_request_headers();
    }

    // @todo This needs proper escaping.  I'm not entirely sure how to do that.
    return isset($this->requestHeaders[$header]) ? $this->requestHeader : NULL;
  }

}

interface DrupalContextInterface extends ArrayAccess {

}

class DrupalContext implements DrupalContextInterface {

  protected $queryString;

  protected $handlerClasses = array();

  protected $handlers = array();

  protected $context = array();

  protected $request = NULL;

  protected $locked = FALSE;

  public function __construct(DrupalRequestInterface $request) {
    $this->request = $request;

    $this->queryString = $this->request->get['q'];
  }

  /**
   * Access the HTTP request information.
   *
   * @return DrupalRequestInterface
   */
  public function request() {
    return $this->request;
  }

  public function arg($index) {
    // @todo Eventually reverse this, so arg() calls context->arg().
    return arg($index, $this->queryString);
  }

  public function offsetExists($offset) {
    return isset($this->handlers[$offset]);
  }

  public function offsetGet($offset) {
    if (!$this->locked) {
      throw new ButlerNotLockedException(t('This butler object has not been locked. It must be locked before it can be used.'));
    }

    if (!isset($this->context[$offset])) {
      $offset_elements = explode(':', $offset);
      $args = array();
      while ($offset_elements && !isset($this->handlerClasses[$offset])) {
        $args[] = array_pop($offset_elements);
        $offset = implode(':', $offset_elements);
      }

      $offset = implode(':', $offset_elements);
      if (class_exists($this->handlerClasses[$offset]['class'])) {
        $this->handlers[$offset] = new $this->handlerClasses[$offset]['class']($this, $this->handlerClasses[$offset]['params']);
        $this->context[$offset] = $this->handlers[$offset]->getValue($args);
      }
      else {
        $this->context[$offset] = NULL;
      }
    }

    return $this->context[$offset];
  }

  public function offsetSet($offset, $value) {
    if ($this->locked) {
      throw new ButlerLockedException(t('This butler object has been locked. It no longer accepts new explicit context sets.'));
    }
    // Set an explicit override for a given context value.
    $this->context[$offset] = $value;
  }

  public function offsetUnset($offset) {
    if ($this->locked) {
      throw new ButlerLockedException(t('This butler object has been locked. It no longer accepts context clears.'));
    }
    // Unset any saved context so that it can be regenerated by the context
    // handler as needed.
    unset($this->context[$offset]);
  }

  public function registerHandler($offset, $class, $params = array()) {
    if ($this->locked) {
      throw new ButlerLockedException(t('This butler object has been locked. It no longer accepts new handler registrations.'));
    }
    $this->handlerClasses[$offset] = array('class' => $class, 'params' => $params);
  }

  /**
   * Lock this context object against futher modification.
   *
   * This allows us to setup a mocked context object very easily, and then
   * make it immutable so we know that it won't change out from under us.
   */
  public function lock() {
    $this->locked = TRUE;
  }
}

/**
 * Implements hook_menu().
 */
function butler_menu() {
  $items = array();

  $items['butler'] = array(
    'title' => 'Butler testing',
    'page callback' => 'butler_test',
    'access arguments' => array('access content'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

function butler_test() {

  $butler = new DrupalContext(new DrupalRequestHttp());

  module_invoke_all('context_init', $butler);

  $butler->lock();

  dpm($butler);

  $q = $butler['http:get:q'];

  dpm($q);

  return 'x';
}

/**
 * Implements hook_context_init().
 *
 * @param DrupalContextInterface $butler
 */
function butler_context_init(DrupalContextInterface $butler) {
  $butler->registerHandler('http:get', 'ContextHandlerHttp', array('query' => 'GET'));
  $butler->registerHandler('http:post', 'ContextHandlerHttp', array('query' => 'POST'));
}

class ContextHandlerHttp {

  /**
   * Reference to the context object.
   *
   * Note: This creates a circular reference.  We should probably get rid of it
   * and pass it every time.
   *
   * @var DrupalContextInterface
   */
  protected $context;

  protected $params;

  public function __construct(DrupalContextInterface $context, $params) {
    $this->context = $context;
    $this->params = $params;
  }

  public function getValue($args = array()) {
    $param = $args[0];
    if ($this->params['query'] == 'GET') {
      return $this->context->request()->get($param);
    }
    if ($this->params['query'] == 'POST') {
      return $this->context->request()->post($param);
    }
  }
}

